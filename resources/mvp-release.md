# Пошаговый план реализации MVP с чекбоксами

## Шаг 1: Настройка проекта и инфраструктуры

### Репозиторий и структура

- [X] Создать monorepo репозиторий на GitHub.
- [X] Настроить структуру папок:
  ```
  hospital-edu/
  ├── user-service/
  ├── appointment-service/
  ├── notification-service/
  ├── docker-compose.yml
  └── README.md
  ```
- [X] Добавить корневой `settings.gradle` для управления модулями.
- [Х] Добавить общий плагин для управления зависимостями внутри проекта.

### Docker Compose

- [ ] Добавить базовый `docker-compose.yml`:
    - [X] MongoDB.
    - [X] PostgreSQL.
    - [X] Kafka.
    - [X] Maildev.

- [X] Проверить запуск инфраструктурных сервисов через `docker-compose up`.

---

## Шаг 2: Реализация `user-service`

### Создание сервиса

- [X] Создать папку `services/user-service`.
- [X] Инициализировать проект Spring Boot через Spring Initializr.
- [X] Добавить зависимости: **Spring Web**, **Spring Data MongoDB**, **Lombok**, **DevTools**.

### Настройка MongoDB

- [X] Добавить `application.properties` для подключения к MongoDB.
- [ ] Проверить подключение к базе через клиент MongoDB или лог сервиса.

### Логика сервиса

- [X] Добавить базовую структуру папок:
  ```
  com.hospital.user
  ├── edu.medical.demo.controller
  ├── service
  ├── edu.medical.demo.repository
  └── edu.medical.demo.model
  ```
- [X] Создать модель пользователя `User` с полями: ID, имя, email, телефон.
- [X] Написать интерфейс репозитория `UserRepository`.
- [X] Создать сервисный класс `UserService` для работы с репозиторием.
- [X] Добавить контроллер `UserController` с эндпоинтами:
    - [X] **POST /users**: Создание нового пользователя.
    - [X] **GET /users/{id}**: Получение информации о пользователе.

### Тестирование

- [X] Тестировать API через Postman.
- [X] Проверить, что данные сохраняются в Postgres.

---

## Шаг 3: Реализация `appointment-service`

### Создание сервиса

- [X] Создать папку `services/appointment-service`.
- [X] Инициализировать проект Spring Boot через Spring Initializr.
- [X] Добавить зависимости: **Spring Web**, **Spring Data JPA**, **Lombok**, **DevTools**.

### Настройка PostgreSQL

- [ ] Добавить `application.properties` для подключения к PostgreSQL.
- [ ] Проверить подключение к базе через лог сервиса.

### Логика сервиса

- [ ] Добавить базовую структуру папок:
  ```
  com.hospital.appointment
  ├── edu.medical.demo.controller
  ├── service
  ├── edu.medical.demo.repository
  └── edu.medical.demo.model
  ```
- [ ] Создать модель записи `Appointment` с полями: ID, ID пользователя, ID врача, дата/время.
- [ ] Написать интерфейс репозитория `AppointmentRepository`.
- [ ] Создать сервисный класс `AppointmentService` для работы с репозиторием.
- [ ] Добавить контроллер `AppointmentController` с эндпоинтами:
    - [ ] **POST /appointments**: Создание записи на прием.
    - [ ] **GET /appointments/{id}**: Получение информации о записи.

### Связь с `user-service`

- [ ] Добавить HTTP-клиент для запросов к `user-service` (например, RestTemplate).
- [ ] Реализовать валидацию пользователя перед записью.

### Тестирование

- [ ] Тестировать API через Postman.
- [ ] Проверить, что данные сохраняются в PostgreSQL.

---

## Шаг 4: Реализация `notification-service`

### Создание сервиса

- [ ] Создать папку `services/notification-service`.
- [ ] Инициализировать проект Spring Boot через Spring Initializr.
- [ ] Добавить зависимости: **Spring Web**, **Spring Kafka**, **Spring Mail**, **Lombok**, **DevTools**.

### Настройка Kafka

- [ ] Добавить `application.properties` для подключения к Kafka.
- [ ] Проверить соединение с Kafka.

### Логика сервиса

- [ ] Добавить базовую структуру папок:
  ```
  com.hospital.notification
  ├── listener
  ├── service
  └── edu.medical.demo.model
  ```
- [ ] Написать Kafka Listener для обработки сообщений о новых записях.
- [ ] Реализовать отправку email с использованием `JavaMailSender`.
- [ ] Настроить отправку через Maildev (SMTP).

### Тестирование

- [ ] Создать тестовый топик в Kafka для сообщений.
- [ ] Проверить отправку писем через Maildev.

---

## Шаг 5: Интеграция и настройка Docker Compose

### Интеграция сервисов

- [ ] Настроить `docker-compose.yml` для сборки всех сервисов.
- [ ] Добавить зависимости между сервисами (например, `user-service` зависит от MongoDB).

### Тестирование

- [ ] Поднять все контейнеры через `docker-compose up`.
- [ ] Проверить взаимодействие сервисов через Postman.

---

### Расширенный план MVP с мониторингом и логированием

---

## Шаг 6: Добавление мониторинга и логирования

### Логирование (ELK-стек)

- [ ] **Elasticsearch**: Настроить базу для хранения логов.
    - [ ] Добавить сервис `elasticsearch` в `docker-compose.yml`.
- [ ] **Logstash**: Добавить обработку логов.
    - [ ] Настроить конфигурацию Logstash для сбора логов из всех микросервисов.
    - [ ] Прописать шаблон для парсинга JSON-логов.
- [ ] **Kibana**: Настроить визуализацию логов.
    - [ ] Подключить Kibana к Elasticsearch.
    - [ ] Создать дашборды для мониторинга логов каждого сервиса.
- [ ] Добавить библиотеку **Logback** в каждый сервис для отправки логов в Logstash.

---

### Метрики (Prometheus и Grafana)

- [ ] **Prometheus**: Настроить сбор метрик.
    - [ ] Добавить сервис `prometheus` в `docker-compose.yml`.
    - [ ] Подключить Spring Actuator в каждом микросервисе.
    - [ ] Настроить endpoints `/actuator/prometheus` для метрик.
    - [ ] Прописать конфигурацию Prometheus для сбора метрик:
- [ ] **Grafana**: Добавить визуализацию метрик.
    - [ ] Установить сервис Grafana в `docker-compose.yml`.
    - [ ] Подключить источник данных Prometheus.
    - [ ] Создать дашборды для мониторинга состояния микросервисов (CPU, Memory, Latency).

---

### Трассировка (Jaeger или Zipkin)

- [ ] **Jaeger**: Настроить трассировку запросов.
    - [ ] Добавить сервис `jaeger` в `docker-compose.yml`.
    - [ ] Подключить Spring Sleuth в каждом микросервисе.
    - [ ] Настроить отправку данных в Jaeger.
    - [ ] Проверить трассировку запросов между `user-service` и `appointment-service`.

---

### Шаг 7: Повышение отказоустойчивости

- [ ] Добавить **Hystrix** или **Resilience4j** для управления отказами.
    - [ ] Настроить fallback методы для запросов между сервисами.
    - [ ] Реализовать таймауты и ограничение потоков.

---

### Шаг 8: CI/CD

- [ ] **GitHub Actions**: Настроить pipeline для сборки и деплоя микросервисов.
    - [ ] Добавить отдельные задачи для запуска тестов.
    - [ ] Настроить автоматический деплой Docker-образов в Docker Hub.
- [ ] **Kubernetes (опционально)**: Подготовить YAML-манифесты для деплоя в кластер.

---

### Шаг 9: Документация и поддержка

- [ ] **OpenAPI (Swagger)**: Добавить генерацию документации API.
    - [ ] Установить зависимость `springdoc-openapi-ui` для каждого микросервиса.
    - [ ] Проверить, что все эндпоинты задокументированы.
- [ ] **Документация проекта**:
    - [ ] Обновить README.md с описанием архитектуры и шагов развертывания.
    - [ ] Создать схему архитектуры (использовать Diagrams.net или Lucidchart).

---

### Итоговый чеклист

После выполнения всех шагов:

- **Сервисы**:
    - [ ] `user-service` работает и взаимодействует с MongoDB.
    - [ ] `appointment-service` сохраняет данные в PostgreSQL.
    - [ ] `notification-service` отправляет уведомления через Maildev.
- **Мониторинг**:
    - [ ] Логи всех сервисов видны в Kibana.
    - [ ] Метрики доступны в Grafana.
    - [ ] Трассировка запросов работает через Jaeger.
- **Инфраструктура**:
    - [ ] Все сервисы запускаются через `docker-compose`.
    - [ ] Нет конфликтов портов.
- **Документация**:
    - [ ] OpenAPI документация готова.
    - [ ] README.md покрывает шаги развертывания и использования.

Этот план позволяет вам не только реализовать MVP, но и заложить основу для масштабирования и поддержки вашего проекта.

## Итог

После выполнения всех шагов MVP должно поддерживать:

- Регистрацию пользователя.
- Создание записи к врачу.
- Отправку уведомления врачу через Maildev.